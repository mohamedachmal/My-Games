<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser Game Arcade</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');

        :root {
            --bg-color: #1a1a2e;
            --primary-color: #0f3460;
            --secondary-color: #e94560;
            --font-color: #f0f0f0;
            --x-color: #4dccc6;
            --o-color: #ff9a8d;
            --cell-bg: #16213e;
            --border-glow: rgba(233, 69, 96, 0.4);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Poppins', sans-serif;
            background-color: var(--bg-color);
            color: var(--font-color);
            padding: 10px;
        }

        .game-arcade {
            max-width: 900px;
            margin: 0 auto;
            background-color: var(--primary-color);
            border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
            border: 2px solid var(--secondary-color);
            overflow: hidden;
            position: relative;
        }
        
        /* --- HOME UI STYLES START --- */
        .arcade-header {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 15px 20px;
            background-color: var(--cell-bg);
            position: relative;
        }
        .back-button {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: var(--font-color);
            font-size: 2rem;
            cursor: pointer;
            padding: 0 10px;
        }
        .arcade-logo {
            color: var(--secondary-color);
            font-size: 1.8rem;
            text-shadow: 0 0 10px var(--secondary-color);
        }
        #home-view {
            padding: 20px;
        }
        .game-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 15px;
        }
        .game-card {
            background-color: var(--cell-bg);
            padding: 25px 20px;
            border-radius: 10px;
            text-align: center;
            font-size: 1.2rem;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s, box-shadow 0.2s;
            border: 2px solid transparent;
        }
        .game-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px var(--border-glow);
            border-color: var(--secondary-color);
        }
        .game-card .emoji {
            font-size: 1.5rem;
            margin-left: 10px;
        }
        .hidden {
            display: none !important;
        }
        @media (min-width: 600px) {
            .game-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
        @media (min-width: 768px) {
            .game-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        /* --- HOME UI STYLES END --- */

        .game-tabs {
            display: flex;
            background-color: var(--cell-bg);
            overflow-x: auto;
        }

        .tab-link {
            padding: 15px 20px;
            cursor: pointer;
            color: var(--font-color);
            text-decoration: none;
            font-weight: 600;
            transition: all 0.3s ease;
            white-space: nowrap;
        }

        .tab-link:hover {
            background-color: var(--primary-color);
        }

        .tab-link.active {
            background-color: var(--secondary-color);
            color: var(--bg-color);
            text-shadow: 0 0 5px rgba(0,0,0,0.5);
        }

        .game-area {
            padding: 20px;
        }

        .game-wrapper {
            display: none;
        }

        .game-wrapper.active {
            display: block;
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .game-container {
            text-align: center;
        }

        h1 {
            color: var(--secondary-color);
            font-size: 2.5rem;
            margin-bottom: 20px;
            text-shadow: 0 0 10px var(--secondary-color);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .controls label {
            font-size: 0.9rem;
            margin-bottom: 5px;
        }

        .controls select, .controls button, .game-btn {
            background-color: var(--cell-bg);
            color: var(--font-color);
            border: 1px solid var(--secondary-color);
            padding: 8px 12px;
            border-radius: 8px;
            font-family: 'Poppins', sans-serif;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .controls select:hover, .controls button:hover, .game-btn:hover {
            background-color: var(--secondary-color);
            box-shadow: 0 0 15px var(--secondary-color);
        }

        .status-display {
            font-size: 1.2rem;
            font-weight: 600;
            min-height: 30px;
            margin-bottom: 10px;
            transition: color 0.3s ease;
        }
        
        .player-info {
            font-size: 0.9rem;
            margin-bottom: 20px;
            color: #b0b0b0;
        }

        .ttt-stats-container {
            display: flex;
            justify-content: space-around;
            max-width: 320px; /* same as board */
            margin: -10px auto 15px auto;
            font-size: 1rem;
            color: #ccc;
        }

        /* --- Tic Tac Toe --- */
        #tic-tac-toe-board {
            display: grid;
            grid-template-columns: repeat(3, 100px);
            gap: 10px;
            margin: 0 auto 25px auto;
            width: fit-content;
        }
        .ttt-cell {
            width: 100px;
            height: 100px;
            background-color: var(--cell-bg);
            border-radius: 10px;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 4rem;
            font-weight: bold;
            transition: background-color 0.2s ease-in-out;
        }
        .ttt-cell:not(.x):not(.o):hover {
            background-color: #2c3e50;
        }
        .ttt-cell.x, .ttt-cell.o {
            animation: ttt-scale-in 0.3s ease-in-out;
        }
        .ttt-cell.x { color: var(--x-color); }
        .ttt-cell.o { color: var(--o-color); }
        @keyframes ttt-scale-in {
            from { transform: scale(0.5); opacity: 0 ; }
            to { transform: scale(1); opacity: 1 ; }
        }
        .winning-cell {
            animation: win-pulse 0.8s infinite !important;
        }
        @keyframes win-pulse {
            0% { background-color: var(--secondary-color); box-shadow: 0 0 20px var(--secondary-color); }
            50% { background-color: var(--cell-bg); box-shadow: none; }
            100% { background-color: var(--secondary-color); box-shadow: 0 0 20px var(--secondary-color); }
        }

        /* --- Rock Paper Scissors --- */
        #rps-choices { margin: 20px 0; }
        .rps-btn { font-size: 3rem; padding: 10px 20px; margin: 0 10px; }
        #rps-results { display: flex; justify-content: center; align-items: center; gap: 40px; margin-top: 20px; }
        .rps-result-box {
            font-size: 1.2rem;
            border: 2px solid var(--cell-bg);
            padding: 20px;
            border-radius: 10px;
            min-width: 150px;
        }
        .rps-result-box h3 { color: var(--secondary-color); }
        .rps-result-box p { font-size: 2.5rem; }
        .rps-result-box.shaking p {
            animation: shake 0.5s infinite alternate;
        }
        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        /* --- Memory Game --- */
        #memory-board {
            display: grid;
            grid-template-columns: repeat(4, 100px);
            gap: 10px;
            justify-content: center;
            margin-top: 20px;
        }
        .memory-card {
            width: 100px;
            height: 100px;
            background-color: var(--cell-bg);
            border-radius: 10px;
            cursor: pointer;
            position: relative;
            transform-style: preserve-3d;
            transition: transform 0.5s;
        }
        .memory-card.flipped { transform: rotateY(180deg); }
        .memory-card.matched { background-color: var(--secondary-color); transform: rotateY(180deg); }
        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 3rem;
        }
        .card-back { transform: rotateY(180deg); }

        /* --- Snake --- */
        #snake-canvas {
            background-color: var(--cell-bg);
            border: 2px solid var(--secondary-color);
            margin: 0 auto;
        }

        /* --- Connect 4 --- */
        #connect4-board {
            display: grid;
            grid-template-columns: repeat(7, 60px);
            gap: 5px;
            background-color: #0077b6;
            padding: 10px;
            border: 5px solid #03045e;
            border-radius: 10px;
            width: fit-content;
            margin: 20px auto;
        }
        .connect4-cell {
            width: 60px;
            height: 60px;
            background-color: var(--cell-bg);
            border-radius: 50%;
            cursor: pointer;
        }
        .connect4-cell.p1 { background-color: var(--x-color); }
        .connect4-cell.p2 { background-color: var(--o-color); }
        .connect4-col {
            /*display: contents;*/
            display: flex;
            flex-direction: column ; /* bottom of array = bottom visually */
            gap: 3px;
        }
        .connect4-col:hover .connect4-cell:not(.p1):not(.p2) {
             background-color: #2c3e50;
        }
        .connect4-cell.winner {
            box-shadow: 0 0 10px 5px gold;
            transform: scale(1.1);
            transition: all 0.3s;
        }

        /* --- Hangman --- */
        #hangman-drawing {
            height: 200px;
            margin: 20px auto;
            position: relative;
        }
        .hangman-part {
            background-color: var(--font-color);
            position: absolute;
            display: none;
        }
        #hangman-scaffold-1 { display: block; height: 200px; width: 5px; top: 0; left: 50px; }
        #hangman-scaffold-2 { display: block; height: 5px; width: 100px; top: 0; left: 50px; }
        #hangman-scaffold-3 { display: block; height: 30px; width: 5px; top: 0; left: 150px; }
        #hangman-head { width: 40px; height: 40px; border: 5px solid var(--font-color); border-radius: 50%; top: 30px; left: 130px; background: none; }
        #hangman-body { width: 5px; height: 60px; top: 70px; left: 150px; }
        #hangman-arm-l { width: 5px; height: 40px; top: 80px; left: 135px; transform: rotate(45deg); }
        #hangman-arm-r { width: 5px; height: 40px; top: 80px; left: 165px; transform: rotate(-45deg); }
        #hangman-leg-l { width: 5px; height: 40px; top: 125px; left: 135px; transform: rotate(45deg); }
        #hangman-leg-r { width: 5px; height: 40px; top: 125px; left: 165px; transform: rotate(-45deg); }

        #hangman-word {
            display: flex;
            gap: 10px;
            justify-content: center;
            font-size: 2rem;
            margin-bottom: 20px;
            min-height: 50px;
        }
        .letter-placeholder {
            width: 40px;
            border-bottom: 5px solid var(--secondary-color);
            text-align: center;
        }
        #hangman-keys {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            max-width: 600px;
            margin: 0 auto;
        }
        .key-btn {
            width: 40px;
            height: 40px;
            font-size: 1.2rem;
        }
        .key-btn:disabled {
            background-color: #555;
            cursor: not-allowed;
            border-color: #777;
        }

        /* --- Puzzle --- */
        .puzzle-board {
            display: grid;
            grid-template-columns: repeat(3, 80px);
            grid-template-rows: repeat(3, 80px);
            gap: 5px;
            margin: 20px auto 0;
            width: fit-content;
            background-color: var(--primary-color);
            border: 5px solid var(--cell-bg);
            border-radius: 10px;
            padding: 5px;
        }
        .puzzle-tile {
            width: 80px;
            height: 80px;
            background-color: var(--cell-bg);
            color: var(--font-color);
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2.5rem;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.3s, transform 0.2s;
        }
        .puzzle-tile:hover {
            background-color: #2c3e50;
        }
        .puzzle-tile.empty {
            background-color: transparent;
            cursor: default;
        }
        .puzzle-board.win .puzzle-tile:not(.empty) {
            background-color: var(--x-color);
            animation: win-pulse 0.8s;
        }

        /* --- Responsive Styles --- */
        @media (max-width: 768px) {
            .game-area {
                padding: 15px;
            }
            h1 {
                font-size: 2rem;
                margin-bottom: 15px;
            }
            .status-display {
                font-size: 1rem;
            }
            .controls {
                flex-direction: column;
                gap: 10px;
            }
            .controls select, .controls button, .game-btn {
                padding: 10px;
                width: 100%;
                max-width: 250px;
            }
            #tic-tac-toe-board {
                grid-template-columns: repeat(3, 80px);
                gap: 5px;
            }
            .ttt-cell {
                width: 80px;
                height: 80px;
                font-size: 3rem;
            }
            .ttt-stats-container {
                max-width: 250px;
                font-size: 0.9rem;
            }
            .rps-btn {
                font-size: 2.5rem;
                padding: 8px 15px;
                margin: 0 5px;
            }
            #rps-results {
                flex-direction: column;
                gap: 20px;
            }
            .rps-result-box {
                min-width: unset;
                width: 100%;
                max-width: 200px;
            }
            #memory-board {
                grid-template-columns: repeat(4, 70px);
                gap: 5px;
            }
            .memory-card {
                width: 70px;
                height: 70px;
            }
            .card-face {
                font-size: 2rem;
            }
            #snake-canvas {
                width: 300px;
                height: 300px;
            }
            #connect4-board {
                grid-template-columns: repeat(7, 40px);
                gap: 3px;
                padding: 5px;
            }
            .connect4-cell {
                width: 40px;
                height: 40px;
            }
            #hangman-word {
                font-size: 1.5rem;
                gap: 5px;
            }
            .letter-placeholder {
                width: 30px;
                border-bottom-width: 3px;
            }
            #hangman-keys {
                max-width: 320px;
                gap: 5px;
            }
            .key-btn {
                width: 35px;
                height: 35px;
                font-size: 1rem;
            }
        }

        @media (max-width: 480px) {
            .arcade-logo {
                font-size: 1.5rem;
            }
            .game-area {
                padding: 10px;
            }
            #tic-tac-toe-board {
                grid-template-columns: repeat(3, 70px);
            }
            .ttt-cell {
                width: 70px;
                height: 70px;
                font-size: 2.5rem;
            }
            .rps-btn {
                font-size: 2rem;
                padding: 6px 10px;
            }
            #memory-board {
                grid-template-columns: repeat(4, 60px);
            }
            .memory-card {
                width: 60px;
                height: 60px;
            }
            .card-face {
                font-size: 1.5rem;
            }
            #snake-canvas {
                width: 250px;
                height: 250px;
            }
            #connect4-board {
                grid-template-columns: repeat(7, 35px);
            }
            .connect4-cell {
                width: 35px;
                height: 35px;
            }
            #hangman-drawing {
                height: 150px;
            }
            #hangman-scaffold-1 { height: 150px; }
            #hangman-scaffold-2 { width: 75px; }
            #hangman-scaffold-3 { height: 20px; left: 100px; }
            #hangman-head { width: 30px; height: 30px; top: 20px; left: 85px;}
            #hangman-body { height: 40px; top: 50px; left: 100px;}
            #hangman-arm-l { height: 30px; top: 55px; left: 90px;}
            #hangman-arm-r { height: 30px; top: 55px; left: 110px;}
            #hangman-leg-l { height: 30px; top: 80px; left: 90px;}
            #hangman-leg-r { height: 30px; top: 80px; left: 110px;}
            
            #hangman-word {
                font-size: 1.2rem;
            }
            .letter-placeholder {
                width: 25px;
            }
            #hangman-keys {
                max-width: 280px;
            }
            .key-btn {
                width: 30px;
                height: 30px;
                font-size: 0.9rem;
            }
            .puzzle-board {
                grid-template-columns: repeat(3, 70px);
                grid-template-rows: repeat(3, 70px);
            }
            .puzzle-tile {
                width: 70px;
                height: 70px;
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>

<div class="game-arcade">
    
    <!-- HOME UI START -->
    <header class="arcade-header">
        <button id="back-button" class="back-button hidden">&larr;</button>
        <h1 class="arcade-logo">Game Arcade</h1>
    </header>

    <div id="home-view">
        <div class="game-grid">
            <div class="game-card" data-game="tic-tac-toe">
                Tic-Tac-Toe <span class="emoji">‚úèÔ∏è</span>
            </div>
            <div class="game-card" data-game="rps">
                Rock Paper Scissors <span class="emoji">‚úä</span>
            </div>
            <div class="game-card" data-game="memory">
                Memory Game <span class="emoji">üß†</span>
            </div>
            <div class="game-card" data-game="snake">
                Snake <span class="emoji">üêç</span>
            </div>
            <div class="game-card" data-game="connect4">
                Connect 4 <span class="emoji">üîµ</span>
            </div>
            <div class="game-card" data-game="hangman">
                Hangman <span class="emoji">ü§î</span>
            </div>
             <div class="game-card" data-game="puzzle">
                Sliding Puzzle <span class="emoji">üß©</span>
            </div>
        </div>
    </div>
    <!-- HOME UI END -->

    <div id="game-view" class="hidden">
        <nav class="game-tabs" style="display: none;">
            <a href="#" class="tab-link active" data-game="tic-tac-toe">Tic-Tac-Toe</a>
            <a href="#" class="tab-link" data-game="rps">Rock Paper Scissors</a>
            <a href="#" class="tab-link" data-game="memory">Memory Game</a>
            <a href="#" class="tab-link" data-game="snake">Snake</a>
            <a href="#" class="tab-link" data-game="connect4">Connect 4</a>
            <a href="#" class="tab-link" data-game="hangman">Hangman</a>
            <a href="#" class="tab-link" data-game="puzzle">Puzzle</a>
        </nav>

        <main class="game-area">
            <!-- Tic-Tac-Toe -->
            <div id="tic-tac-toe" class="game-wrapper">
                <div class="game-container">
                    <h1>Tic-Tac-Toe</h1>
                    <div class="controls">
                        <div class="control-group">
                            <label for="ttt-game-mode">Game Mode</label>
                            <select id="ttt-game-mode">
                                <option value="single">Single Player</option>
                                <option value="multiplayer">Multiplayer</option>
                            </select>
                        </div>
                        <div class="control-group" id="ttt-difficulty-group">
                            <label for="ttt-difficulty">Difficulty</label>
                            <select id="ttt-difficulty">
                                <option value="easy">Easy</option>
                                <option value="medium">Medium</option>
                                <option value="hard">Impossible</option>
                            </select>
                        </div>
                    </div>
                    <div id="ttt-status" class="status-display">Choose a mode to start!</div>
                    <div id="ttt-player-info" class="player-info"></div>
                    <div id="ttt-extra-info" class="ttt-stats-container">
                        <!--div>Time: <span id="ttt-timer">0s</span></div-->
                        <div>Score: <span id="ttt-score">X 0 - 0 O</span></div>
                    </div>
                    <div id="tic-tac-toe-board">
                        <div class="ttt-cell" data-cell-index="0"></div>
                        <div class="ttt-cell" data-cell-index="1"></div>
                        <div class="ttt-cell" data-cell-index="2"></div>
                        <div class="ttt-cell" data-cell-index="3"></div>
                        <div class="ttt-cell" data-cell-index="4"></div>
                        <div class="ttt-cell" data-cell-index="5"></div>
                        <div class="ttt-cell" data-cell-index="6"></div>
                        <div class="ttt-cell" data-cell-index="7"></div>
                        <div class="ttt-cell" data-cell-index="8"></div>
                    </div>
                    <button id="ttt-restart-btn" class="game-btn">Restart Game</button>
                </div>
            </div>

            <!-- Rock Paper Scissors -->
            <div id="rps" class="game-wrapper">
                 <div class="game-container">
                    <h1>Rock Paper Scissors</h1>
                    <div id="rps-score" class="status-display">Player 0 - 0 Computer</div>
                    <div id="rps-status" class="status-display">Make your choice!</div>
                    <div id="rps-choices">
                        <button class="rps-btn" data-choice="rock">‚úä</button>
                        <button class="rps-btn" data-choice="paper">‚úã</button>
                        <button class="rps-btn" data-choice="scissors">‚úåÔ∏è</button>
                    </div>
                    <div id="rps-results">
                        <div class="rps-result-box">
                            <h3>You</h3>
                            <p id="rps-player-choice">?</p>
                        </div>
                         <div class="rps-result-box">
                            <h3>Computer</h3>
                            <p id="rps-computer-choice">?</p>
                        </div>
                    </div>
                 </div>
            </div>
            
            <!-- Memory Game -->
            <div id="memory" class="game-wrapper">
                <div class="game-container">
                    <h1>Memory Game</h1>
                    <div class="ttt-stats-container">
                        <div>Time: <span id="memory-timer">0s</span></div>
                        <div>Clicks: <span id="memory-clicks">0</span></div>
                    </div>
                    <div id="memory-status" class="status-display">Match the pairs!</div>
                    <div id="memory-board"></div>
                    <button id="memory-restart-btn" class="game-btn">Restart Game</button>
                </div>
            </div>
            
            <!-- Snake -->
            <div id="snake" class="game-wrapper">
                 <div class="game-container">
                    <h1>Snake</h1>
                    <div id="snake-status" class="status-display">Score: 0</div>
                    <canvas id="snake-canvas" width="400" height="400"></canvas>
                    <p style="margin-top: 10px;">Use Arrow Keys to move</p>
                </div>
            </div>
            
            <!-- Connect 4 -->
            <div id="connect4" class="game-wrapper">
                <div class="game-container">
                    <h1>Connect 4</h1>
                    <div class="controls">
                        <div class="control-group">
                            <label for="c4-game-mode">Game Mode</label>
                            <select id="c4-game-mode">
                                <option value="single">Single Player</option>
                                <option value="multiplayer" selected>Multiplayer</option>
                            </select>
                        </div>
                        <div class="control-group" id="c4-difficulty-group" style="display: none;">
                            <label for="c4-difficulty">Difficulty</label>
                            <select id="c4-difficulty">
                                <option value="easy">Easy</option>
                                <option value="medium">Medium</option>
                                <option value="hard">Impossible</option>
                            </select>
                        </div>
                    </div>
                    <div id="connect4-score" class="status-display">P1 0 - 0 P2</div>
                    <div id="connect4-instructions" style="margin-bottom: 20px; line-height: 1.5;">
                        <p>Player 1: <span style="color: var(--x-color); font-weight: bold;"> üîµ </span></p>
                        <p>Player 2: <span style="color: var(--o-color); font-weight: bold;"> üî¥</span></p>
                    </div>
                    <div id="connect4-status" class="status-display">Player 1's Turn</div>
                    <div id="connect4-board"></div>
                    <button id="connect4-restart-btn" class="game-btn">Restart Game</button>
                </div>
            </div>
            
            <!-- Hangman -->
            <div id="hangman" class="game-wrapper">
                <div class="game-container">
                    <h1>Hangman</h1>
                    <div id="hangman-status" class="status-display">Guess the word!</div>
                    <div id="hangman-drawing">
                        <div class="hangman-part" id="hangman-scaffold-1"></div>
                        <div class="hangman-part" id="hangman-scaffold-2"></div>
                        <div class="hangman-part" id="hangman-scaffold-3"></div>
                        <div class="hangman-part" id="hangman-head"></div>
                        <div class="hangman-part" id="hangman-body"></div>
                        <div class="hangman-part" id="hangman-arm-l"></div>
                        <div class="hangman-part" id="hangman-arm-r"></div>
                        <div class="hangman-part" id="hangman-leg-l"></div>
                        <div class="hangman-part" id="hangman-leg-r"></div>
                    </div>
                    <div id="hangman-word"></div>
                    <div id="hangman-keys"></div>
                    <button id="hangman-restart-btn" class="game-btn">New Word</button>
                </div>
            </div>
            
            <!-- Puzzle -->
            <div id="puzzle" class="game-wrapper">
                <div class="game-container">
                    <h1>Sliding Puzzle</h1>
                    <div id="puzzle-status" class="status-display">Shuffle to start!</div>
                    <div id="puzzle-board" class="puzzle-board"></div>
                    <button id="puzzle-restart-btn" class="game-btn" style="margin-top: 20px;">Shuffle</button>
                </div>
            </div>

        </main>
    </div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {

    // --- GAME LOGIC OBJECTS ---
    const TicTacToe = {
        // Elements
        statusDisplay: null, playerInfoDisplay: null, cells: null,
        gameModeSelect: null, difficultySelect: null, difficultyGroup: null, restartBtn: null,
        timerDisplay: null, scoreDisplay: null,
        // State
        gameActive: false, currentPlayer: 'X', board: [], gameMode: 'single', difficulty: 'hard',
        humanPlayer: 'X', aiPlayer: 'O', firstPlayerOfRound: 'O',
        score: { x: 0, o: 0 },
        timerInterval: null, secondsElapsed: 0,
        keyListener: null,
        // Constants
        winningConditions: [
            [0, 1, 2], [3, 4, 5], [6, 7, 8], [0, 3, 6], [1, 4, 7], [2, 5, 8], [0, 4, 8], [2, 4, 6]
        ],
        statusMessages: {
            xTurn: "Player X's Turn", oTurn: "Player O's Turn", xWin: "Player X wins!", oWin: "Player O wins!",
            draw: "Game ended in a draw!", aiTurn: "Robot is thinking...", start: "Choose a mode to start!"
        },
        
        init() {
            // Cache DOM elements
            this.statusDisplay = document.getElementById('ttt-status');
            this.playerInfoDisplay = document.getElementById('ttt-player-info');
            this.cells = document.querySelectorAll('.ttt-cell');
            this.gameModeSelect = document.getElementById('ttt-game-mode');
            this.difficultySelect = document.getElementById('ttt-difficulty');
            this.difficultyGroup = document.getElementById('ttt-difficulty-group');
            this.restartBtn = document.getElementById('ttt-restart-btn');
            this.timerDisplay = document.getElementById('ttt-timer');
            this.scoreDisplay = document.getElementById('ttt-score');
            
            // Bind event listeners
            this.gameModeSelect.addEventListener('change', this.startGame.bind(this));
            this.difficultySelect.addEventListener('change', this.startGame.bind(this));
            this.restartBtn.addEventListener('click', this.startGame.bind(this)); // Removed confirmation
            this.cells.forEach(cell => cell.addEventListener('click', this.handleCellClick.bind(this)));
            this.keyListener = this.handleKeyPress.bind(this);
            document.addEventListener('keydown', this.keyListener);
            
            this.updateScoreDisplay();
            this.startGame();
        },

        stop() {
            if (this.keyListener) {
                document.removeEventListener('keydown', this.keyListener);
                this.keyListener = null;
            }
            if(this.timerInterval) clearInterval(this.timerInterval);
        },

        handleKeyPress(e) {
            if (document.getElementById('tic-tac-toe').classList.contains('active')) {
                const key = parseInt(e.key);
                if (key >= 1 && key <= 9) {
                    e.preventDefault();
                    this.cells[key - 1].click();
                }
            }
        },

        startGame() {
            this.gameMode = this.gameModeSelect.value;
            this.difficulty = this.difficultySelect.value;
            this.difficultyGroup.style.display = this.gameMode === 'single' ? 'flex' : 'none';
            this.gameActive = true;
            this.board = Array(9).fill('');
            this.cells.forEach(cell => {
                cell.className = 'ttt-cell';
                cell.textContent = '';
            });
            this.statusDisplay.style.color = 'var(--font-color)';
            this.startTimer();

            if (this.gameMode === 'single') {
                this.playerInfoDisplay.textContent = `X: You | O: Robot`;
                this.firstPlayerOfRound = (this.firstPlayerOfRound === this.humanPlayer) ? this.aiPlayer : this.humanPlayer;
                this.currentPlayer = this.firstPlayerOfRound;
                
                if (this.currentPlayer === this.aiPlayer) {
                    this.statusDisplay.textContent = this.statusMessages.aiTurn;
                    setTimeout(() => this.robotMove(), 700);
                } else {
                    this.statusDisplay.textContent = this.statusMessages.xTurn;
                }
            } else {
                this.playerInfoDisplay.textContent = `X: Player 1 | O: Player 2`;
                this.currentPlayer = 'X';
                this.statusDisplay.textContent = this.statusMessages.xTurn;
            }
            this.updateTurnIndicator();
        },

        handleCellClick(e) {
            const clickedCellIndex = parseInt(e.target.getAttribute('data-cell-index'));
            if (this.board[clickedCellIndex] !== '' || !this.gameActive) return;
            this.makeMove(e.target, clickedCellIndex, this.currentPlayer);
            if (this.gameActive) {
                this.switchPlayer();
                if (this.gameMode === 'single' && this.currentPlayer === this.aiPlayer) {
                    this.statusDisplay.textContent = this.statusMessages.aiTurn;
                    setTimeout(() => this.robotMove(), 700);
                }
            }
        },

        makeMove(cell, index, player) {
            this.board[index] = player;
            cell.classList.add(player.toLowerCase());
            cell.textContent = player;
            if (this.checkResult()) return;
        },

        checkResult() {
            let roundWon = false;
            let winCondition;
            let winningPlayer = '';

            for (const condition of this.winningConditions) {
                const [a, b, c] = condition.map(i => this.board[i]);
                if (a && a === b && a === c) {
                    roundWon = true;
                    winCondition = condition;
                    winningPlayer = a;
                    break;
                }
            }

            if (roundWon) {
                this.stopTimer();
                this.statusDisplay.textContent = winningPlayer === 'X' ? this.statusMessages.xWin : this.statusMessages.oWin;
                this.statusDisplay.style.color = winningPlayer === 'X' ? 'var(--x-color)' : 'var(--o-color)';
                this.gameActive = false;
                winCondition.forEach(index => this.cells[index].classList.add('winning-cell'));
                if (winningPlayer === 'X') this.score.x++; else this.score.o++;
                this.updateScoreDisplay();
                //setTimeout(() => this.startGame(), 2000); // Smooth restart
                return true;
            }

            if (!this.board.includes('')) {
                this.stopTimer();
                this.statusDisplay.textContent = this.statusMessages.draw;
                this.statusDisplay.style.color = 'var(--font-color)';
                this.gameActive = false;
                //setTimeout(() => this.startGame(), 2000); // Smooth restart
                return true;
            }
            return false;
        },

        switchPlayer() {
            this.currentPlayer = this.currentPlayer === 'X' ? 'O' : 'X';
            this.updateTurnIndicator();
        },
        
        updateTurnIndicator() {
            if (!this.gameActive) return;
            this.statusDisplay.textContent = this.currentPlayer === 'X' ? this.statusMessages.xTurn : this.statusMessages.oTurn;
            this.statusDisplay.style.color = this.currentPlayer === 'X' ? 'var(--x-color)' : 'var(--o-color)';
        },

        startTimer() {
            if (this.timerInterval) clearInterval(this.timerInterval);
            this.secondsElapsed = 0;
            this.timerDisplay.textContent = '0s';
            this.timerInterval = setInterval(() => {
                this.secondsElapsed++;
                this.timerDisplay.textContent = `${this.secondsElapsed}s`;
            }, 1000);
        },

        stopTimer() {
            clearInterval(this.timerInterval);
        },

        updateScoreDisplay() {
            this.scoreDisplay.textContent = `X ${this.score.x} - ${this.score.o} O`;
        },

        robotMove() {
            if (!this.gameActive) return;
            let move;
            if (this.difficulty === 'easy') move = this.getEasyMove();
            else if (this.difficulty === 'medium') move = this.getMediumMove();
            else move = this.getHardMove();
            if (move !== undefined) this.makeMove(this.cells[move], move, this.aiPlayer);
            if (this.gameActive) this.switchPlayer();
        },
        
        getAvailableMoves(board = this.board) { return board.map((v, i) => v === '' ? i : null).filter(v => v !== null); },
        getEasyMove() { const moves = this.getAvailableMoves(); return moves[Math.floor(Math.random() * moves.length)]; },
        getMediumMove() {
            for (const player of [this.aiPlayer, this.humanPlayer]) {
                for (const move of this.getAvailableMoves()) {
                    let tempBoard = [...this.board]; tempBoard[move] = player;
                    if (this.isWinner(player, tempBoard)) return move;
                }
            }
            const corners = [0, 2, 6, 8];
            const availableCorners = corners.filter(i => this.board[i] === '');
            if (availableCorners.length > 0) return availableCorners[Math.floor(Math.random() * availableCorners.length)];
            if (this.board[4] === '') return 4;
            return this.getEasyMove();
        },
        getHardMove() { return this.minimax([...this.board], this.aiPlayer).index; },
        minimax(newBoard, player) {
            const availSpots = this.getAvailableMoves(newBoard);
            if (this.isWinner(this.humanPlayer, newBoard)) return { score: -10 };
            if (this.isWinner(this.aiPlayer, newBoard)) return { score: 10 };
            if (availSpots.length === 0) return { score: 0 };
            const moves = [];
            for (const spot of availSpots) {
                const move = { index: spot };
                newBoard[spot] = player;
                const result = this.minimax(newBoard, player === this.aiPlayer ? this.humanPlayer : this.aiPlayer);
                move.score = result.score;
                newBoard[spot] = '';
                moves.push(move);
            }
            let bestMove;
            if (player === this.aiPlayer) {
                let bestScore = -Infinity;
                moves.forEach(move => { if (move.score > bestScore) { bestScore = move.score; bestMove = move; } });
            } else {
                let bestScore = Infinity;
                moves.forEach(move => { if (move.score < bestScore) { bestScore = move.score; bestMove = move; } });
            }
            return bestMove;
        },
        isWinner(player, board) {
            return this.winningConditions.some(c => c.every(i => board[i] === player));
        }
    };


    const RockPaperScissors = {
        statusDisplay: null, playerChoiceDisplay: null, computerChoiceDisplay: null, scoreDisplay: null,
        choices: ['rock', 'paper', 'scissors'], emojis: { rock: '‚úä', paper: '‚úã', scissors: '‚úåÔ∏è' },
        score: { player: 0, computer: 0 },
        init() {
            this.statusDisplay = document.getElementById('rps-status');
            this.playerChoiceDisplay = document.getElementById('rps-player-choice');
            this.computerChoiceDisplay = document.getElementById('rps-computer-choice');
            this.scoreDisplay = document.getElementById('rps-score');
            document.querySelectorAll('.rps-btn').forEach(btn => btn.addEventListener('click', e => this.play(e.target.dataset.choice)));
            this.statusDisplay.textContent = 'Make your choice!';
            this.playerChoiceDisplay.textContent = '?';
            this.computerChoiceDisplay.textContent = '?';
            this.updateScoreDisplay();
        },
        updateScoreDisplay() {
            this.scoreDisplay.textContent = `Player ${this.score.player} - ${this.score.computer} Computer`;
        },
        play(playerChoice) {
            // Disable buttons during play
            document.querySelectorAll('.rps-btn').forEach(btn => btn.disabled = true);

            const playerBox = this.playerChoiceDisplay.closest('.rps-result-box');
            const computerBox = this.computerChoiceDisplay.closest('.rps-result-box');

            // Set player choice immediately and start shaking
            this.playerChoiceDisplay.textContent = this.emojis[playerChoice];
            this.computerChoiceDisplay.textContent = '‚ú®'; // Shaking emoji placeholder
            //playerBox.classList.add('shaking');
            computerBox.classList.add('shaking');
            this.statusDisplay.textContent = "Rock, Paper, Scissors, Shoot!";

            setTimeout(() => {
                // Remove shaking animation
                //playerBox.classList.remove('shaking');
                computerBox.classList.remove('shaking');
                
                const computerChoice = this.choices[Math.floor(Math.random() * 3)];
                this.computerChoiceDisplay.textContent = this.emojis[computerChoice];

                if (playerChoice === computerChoice) {
                    this.statusDisplay.textContent = "It's a draw!";
                } else if ((playerChoice === 'rock' && computerChoice === 'scissors') ||
                           (playerChoice === 'paper' && computerChoice === 'rock') ||
                           (playerChoice === 'scissors' && computerChoice === 'paper')) {
                    this.statusDisplay.textContent = "You win!";
                    this.score.player++;
                } else {
                    this.statusDisplay.textContent = "You lose!";
                    this.score.computer++;
                }
                this.updateScoreDisplay();
                // Re-enable buttons after result
                document.querySelectorAll('.rps-btn').forEach(btn => btn.disabled = false);
            }, 1000); // 1-second delay
        }
    };


    const MemoryGame = {
        board: null, statusDisplay: null, timerDisplay: null, clicksDisplay: null,
        cards: ['üê∂', 'üê±', 'üê≠', 'üêπ', 'üê∞', 'ü¶ä', 'üêª', 'üêº', 'üçé', 'üçä', 'üçì', 'üçá', 'üçâ', 'üçå', 'üçç', 'ü•ù', 'üçï', 'üçî', 'üçü', 'üç¶', 'üç©', 'üç™', 'üç¨', 'üç≠'],
        flippedCards: [], matchedPairs: 0, canFlip: true,
        clicks: 0, timerInterval: null, secondsElapsed: 0,
        init() {
            this.board = document.getElementById('memory-board');
            this.statusDisplay = document.getElementById('memory-status');
            this.timerDisplay = document.getElementById('memory-timer');
            this.clicksDisplay = document.getElementById('memory-clicks');
            document.getElementById('memory-restart-btn').addEventListener('click', () => this.startGame());
            this.startGame();
        },
        startTimer() {
            if (this.timerInterval) clearInterval(this.timerInterval);
            this.secondsElapsed = 0;
            this.timerDisplay.textContent = '0s';
            this.timerInterval = setInterval(() => {
                this.secondsElapsed++;
                this.timerDisplay.textContent = `${this.secondsElapsed}s`;
            }, 1000);
        },
        stopTimer() {
            clearInterval(this.timerInterval);
        },
        startGame() {
            this.flippedCards = []; this.matchedPairs = 0; this.canFlip = true;
            this.clicks = 0; this.clicksDisplay.textContent = this.clicks;
            this.stopTimer(); this.startTimer();
            this.statusDisplay.textContent = 'Match the pairs!'; this.board.innerHTML = '';
            
            // Select 8 unique emojis randomly
            const gameEmojis = this.cards.sort(() => 0.5 - Math.random()).slice(0, 8);
            const shuffledCards = [...gameEmojis, ...gameEmojis].sort(() => 0.5 - Math.random());

            shuffledCards.forEach(symbol => {
                const card = document.createElement('div'); card.className = 'memory-card';
                card.dataset.symbol = symbol;
                card.innerHTML = `<div class="card-face card-front"></div><div class="card-face card-back">${symbol}</div>`;
                card.addEventListener('click', () => this.flipCard(card));
                this.board.appendChild(card);
            });
        },
        flipCard(card) {
            if (!this.canFlip || card.classList.contains('flipped') || this.flippedCards.length >= 2) return;
            this.clicks++;
            this.clicksDisplay.textContent = this.clicks;
            
            card.classList.add('flipped'); this.flippedCards.push(card);
            if (this.flippedCards.length === 2) this.checkForMatch();
        },
        checkForMatch() {
            this.canFlip = false; const [card1, card2] = this.flippedCards;
            if (card1.dataset.symbol === card2.dataset.symbol) {
                this.matchedPairs++; card1.classList.add('matched'); card2.classList.add('matched');
                this.flippedCards = []; this.canFlip = true;
                if (this.matchedPairs === (this.board.children.length / 2)) {
                    this.statusDisplay.textContent = 'You found all pairs!';
                    this.stopTimer();
                }
            } else {
                setTimeout(() => {
                    card1.classList.remove('flipped'); card2.classList.remove('flipped');
                    this.flippedCards = []; this.canFlip = true;
                }, 1000);
            }
        }
    };
    const Snake = {
        canvas: null, ctx: null, statusDisplay: null, gridSize: 20, snake: [],
        food: {}, direction: 'right', score: 0, keyListener: null,
        gameInterval: null, gameStarted: false,
        init() {
            this.canvas = document.getElementById('snake-canvas'); this.ctx = this.canvas.getContext('2d');
            this.statusDisplay = document.getElementById('snake-status');
            this.keyListener = this.changeDirection.bind(this); document.addEventListener('keydown', this.keyListener);
            this.gameStarted = false;
            if (this.gameInterval) clearInterval(this.gameInterval); // Clear any previous interval
            this.statusDisplay.textContent = "Press an arrow key to start!";
            this.drawInitialState(); // Draw an empty board with snake head
        },
        stop() {
            document.removeEventListener('keydown', this.keyListener);
            if (this.gameInterval) clearInterval(this.gameInterval);
            this.gameInterval = null;
            this.gameStarted = false;
        },
        startGame() {
            this.snake = [{ x: 10, y: 10 }, { x: 9, y: 10 }, { x: 8, y: 10 }]; // Initial length of 3
            this.direction = 'right'; this.score = 0;
            this.statusDisplay.textContent = `Score: ${this.score}`; this.generateFood();
            this.draw();
            if (this.gameInterval) clearInterval(this.gameInterval);
            this.gameInterval = setInterval(() => this.gameLoop(), 150);
            this.gameStarted = true;
            this.nextDirection = this.direction;
        },
        drawInitialState() {
            this.ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--cell-bg').trim();
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            // Optionally draw the initial snake head or some indicator
            this.ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--x-color').trim();
            this.ctx.fillRect(10 * this.gridSize, 10 * this.gridSize, this.gridSize - 2, this.gridSize - 2);
        },
        gameLoop() {
            // Apply the nextDirection only once per tick
             this.direction = this.nextDirection;

            let head = { ...this.snake[0] };
            if (this.direction === 'right') head.x++; if (this.direction === 'left') head.x--;
            if (this.direction === 'up') head.y--; if (this.direction === 'down') head.y++;
            if (head.x < 0 || head.x >= this.canvas.width / this.gridSize || head.y < 0 || head.y >= this.canvas.height / this.gridSize || this.snake.some(p => p.x === head.x && p.y === head.y)) {
                //This.startGame(); return;
                //This is my code
                clearInterval(this.gameInterval);
                this.gameInterval = null;
                this.gameStarted = false;
                this.statusDisplay.textContent = "Game Over ‚Äî press an arrow key to restart";
                return;
            }
            this.snake.unshift(head);
            if (head.x === this.food.x && head.y === this.food.y) {
                this.score++; this.statusDisplay.textContent = `Score: ${this.score}`; this.generateFood();
            } else { this.snake.pop(); }
            this.draw();
        },
        draw() {
            this.ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--cell-bg').trim();
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            this.ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--x-color').trim();
            this.snake.forEach(part => { this.ctx.fillRect(part.x * this.gridSize, part.y * this.gridSize, this.gridSize - 2, this.gridSize - 2); });
            this.ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--o-color').trim();
            this.ctx.fillRect(this.food.x * this.gridSize, this.food.y * this.gridSize, this.gridSize, this.gridSize);
        },
        generateFood() {
            this.food = { x: Math.floor(Math.random() * (this.canvas.width / this.gridSize)), y: Math.floor(Math.random() * (this.canvas.height / this.gridSize)) };
        },
        
        changeDirection(e) {
            if (!['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) return;
            e.preventDefault(); // Prevent page scrolling
            if (!this.gameStarted) {
                this.startGame();
            }
            const key = e.key;
            if (key === 'ArrowUp' && this.direction !== 'down') this.nextDirection = 'up';
            if (key === 'ArrowDown' && this.direction !== 'up') this.nextDirection = 'down';
            if (key === 'ArrowLeft' && this.direction !== 'right') this.nextDirection = 'left';
            if (key === 'ArrowRight' && this.direction !== 'left') this.nextDirection = 'right';
        }
    };
            const Connect4 = {
            ROWS: 6,
            COLS: 7,
            board: [],
            currentPlayer: 1,
            gameOver: false,
            gameMode: 'multiplayer',
            difficulty: 'hard',
            score: { p1: 0, p2: 0 },
            humanPlayer: 1,
            aiPlayer: 2,
            statusDisplay: null,
            boardEl: null,
            winningCells: [],
            restartListenerAdded: false,
            gameModeSelect: null,
            difficultySelect: null,
            difficultyGroup: null,
            scoreDisplay: null,

            init() {
                this.statusDisplay = document.getElementById('connect4-status');
                this.boardEl = document.getElementById('connect4-board');
                this.gameModeSelect = document.getElementById('c4-game-mode');
                this.difficultySelect = document.getElementById('c4-difficulty');
                this.difficultyGroup = document.getElementById('c4-difficulty-group');
                this.scoreDisplay = document.getElementById('connect4-score');

                if (!this.restartListenerAdded) {
                    document.getElementById('connect4-restart-btn').addEventListener('click', () => this.startGame());
                    this.gameModeSelect.addEventListener('change', () => { this.score.p1 = 0; this.score.p2 = 0; this.startGame(); });
                    this.difficultySelect.addEventListener('change', () => { this.score.p1 = 0; this.score.p2 = 0; this.startGame(); });
                    this.restartListenerAdded = true;
                }

                this.startGame();
            },

            startGame() {
                this.gameMode = this.gameModeSelect.value;
                this.difficulty = this.difficultySelect.value;
                this.difficultyGroup.style.display = this.gameMode === 'single' ? 'flex' : 'none';

                this.board = Array(this.ROWS).fill(null).map(() => Array(this.COLS).fill(0));
                this.currentPlayer = 1;
                this.gameOver = false;
                this.winningCells = [];
                this.updateScoreDisplay();

                if (this.gameMode === 'single') {
                    this.statusDisplay.textContent = "Your Turn";
                    if (this.currentPlayer === this.aiPlayer) {
                        this.statusDisplay.textContent = "Robot is thinking...";
                        setTimeout(() => this.robotMove(), 700);
                    }
                } else {
                    this.statusDisplay.textContent = "Player 1's Turn";
                }
                this.drawBoard();
            },

            updateScoreDisplay() {
                const p1Label = this.gameMode === 'single' ? 'You' : 'P1';
                const p2Label = this.gameMode === 'single' ? 'AI' : 'P2';
                this.scoreDisplay.textContent = `${p1Label} ${this.score.p1} - ${this.score.p2} ${p2Label}`;
            },

            drawBoard() {
                this.boardEl.innerHTML = '';
                for (let c = 0; c < this.COLS; c++) {
                    const colWrapper = document.createElement('div');
                    colWrapper.className = 'connect4-col';
                    colWrapper.dataset.col = c;
                    colWrapper.addEventListener('click', () => this.handleDrop(c));
                    for (let r = 0; r < this.ROWS; r++) {
                        const cell = document.createElement('div');
                        cell.className = 'connect4-cell';
                        if (this.board[r][c] === 1) cell.classList.add('p1');
                        if (this.board[r][c] === 2) cell.classList.add('p2');
                        if (this.winningCells.some(([wr, wc]) => wr === r && wc === c)) {
                            cell.classList.add('winner');
                        }
                        colWrapper.appendChild(cell);
                    }
                    this.boardEl.appendChild(colWrapper);
                }
            },

            handleDrop(col) {
                if (this.gameOver || (this.gameMode === 'single' && this.currentPlayer === this.aiPlayer)) return;

                if(this.makeMove(col, this.currentPlayer)) {
                    if (!this.gameOver) {
                         if (this.gameMode === 'single') {
                            this.currentPlayer = this.aiPlayer;
                            this.statusDisplay.textContent = "Robot is thinking...";
                            setTimeout(() => this.robotMove(), 500);
                        } else {
                            this.currentPlayer = this.currentPlayer === 1 ? 2 : 1;
                            this.statusDisplay.textContent = `Player ${this.currentPlayer}'s Turn`;
                        }
                    }
                }
            },

            makeMove(col, player) {
                 if (this.board[0][col] !== 0) return false;

                let r;
                for (r = this.ROWS - 1; r >= 0; r--) {
                    if (this.board[r][col] === 0) {
                        this.board[r][col] = player;
                        break;
                    }
                }

                const winningCells = this.checkWin(this.board, player);
                if (winningCells) {
                    this.gameOver = true;
                    if (player === 1) this.score.p1++; else this.score.p2++;
                    this.statusDisplay.textContent = this.gameMode === 'single' ? (player === this.humanPlayer ? "You Win!" : "Robot Wins!") : `Player ${player} Wins!`;
                    this.winningCells = winningCells;
                    this.updateScoreDisplay();
                } else if (this.board.flat().every(cell => cell !== 0)) {
                    this.gameOver = true;
                    this.statusDisplay.textContent = "It's a Draw!";
                }
                
                this.drawBoard();
                return true;
            },

           checkWin(board, player) {
                // Check horizontal
                for (let r = 0; r < this.ROWS; r++) {
                    for (let c = 0; c <= this.COLS - 4; c++) {
                        if (board[r][c] === player && board[r][c+1] === player && board[r][c+2] === player && board[r][c+3] === player) {
                            return [[r,c], [r,c+1], [r,c+2], [r,c+3]];
                        }
                    }
                }
                // Check vertical
                for (let r = 0; r <= this.ROWS - 4; r++) {
                    for (let c = 0; c < this.COLS; c++) {
                        if (board[r][c] === player && board[r+1][c] === player && board[r+2][c] === player && board[r+3][c] === player) {
                           return [[r,c], [r+1,c], [r+2,c], [r+3,c]];
                        }
                    }
                }
                // Check diagonal \
                for (let r = 0; r <= this.ROWS - 4; r++) {
                    for (let c = 0; c <= this.COLS - 4; c++) {
                        if (board[r][c] === player && board[r+1][c+1] === player && board[r+2][c+2] === player && board[r+3][c+3] === player) {
                            return [[r,c], [r+1,c+1], [r+2,c+2], [r+3,c+3]];
                        }
                    }
                }
                // Check diagonal /
                for (let r = 3; r < this.ROWS; r++) {
                    for (let c = 0; c <= this.COLS - 4; c++) {
                        if (board[r][c] === player && board[r-1][c+1] === player && board[r-2][c+2] === player && board[r-3][c+3] === player) {
                            return [[r,c], [r-1,c+1], [r-2,c+2], [r-3,c+3]];
                        }
                    }
                }
                return null;
            },

            robotMove() {
                if (this.gameOver) return;
                let move;
                let startTime = performance.now();
                if (this.difficulty === 'easy') {
                    move = this.getEasyMove();
                } else if (this.difficulty === 'medium') {
                    move = this.getMediumMove();
                } else { // hard
                    move = this.getHardMove();
                }
                let endTime = performance.now();
                console.log(`AI move took ${endTime - startTime}ms`);


                if (move !== undefined) {
                    this.makeMove(move, this.aiPlayer);
                }

                if (!this.gameOver) {
                    this.currentPlayer = this.humanPlayer;
                    this.statusDisplay.textContent = "Your Turn";
                }
            },

            getAvailableMoves(board = this.board) {
                const moves = [];
                for (let c = 0; c < this.COLS; c++) {
                    if (board[0][c] === 0) {
                        moves.push(c);
                    }
                }
                return moves;
            },

            getEasyMove() {
                const moves = this.getAvailableMoves();
                return moves[Math.floor(Math.random() * moves.length)];
            },

            getMediumMove() {
                const availableMoves = this.getAvailableMoves();
                // AI checks if it can win
                for (const move of availableMoves) {
                    if (this.isWinningMove(move, this.aiPlayer, this.board)) return move;
                }
                // AI checks if it needs to block
                for (const move of availableMoves) {
                     if (this.isWinningMove(move, this.humanPlayer, this.board)) return move;
                }
                // Prioritize center
                const centerMoves = [3, 2, 4, 1, 5, 0, 6];
                for(const move of centerMoves) {
                    if(availableMoves.includes(move)) return move;
                }
                return this.getEasyMove(); // Fallback
            },
            
            isWinningMove(col, player, board) {
                let tempBoard = board.map(row => [...row]);
                let r;
                for (r = this.ROWS - 1; r >= 0; r--) {
                    if (tempBoard[r][col] === 0) {
                        tempBoard[r][col] = player;
                        break;
                    }
                }
                if (r < 0) return false; // Column was full
                const win = this.checkWin(tempBoard, player) !== null;
                return win;
            },

            getHardMove() {
                // The depth can be adjusted. 5 is a decent balance of strength and speed.
                const result = this.minimax(this.board, 5, -Infinity, Infinity, true);
                console.log("Minimax analysis:", result);
                return result.col;
            },

            minimax(board, depth, alpha, beta, isMaximizing) {
                const isTerminal = this.isTerminalNode(board);
                if (depth === 0 || isTerminal.result) {
                    return { col: null, score: this.evaluateBoard(board, this.aiPlayer) - this.evaluateBoard(board, this.humanPlayer) };
                }
                
                const availableMoves = this.getAvailableMoves(board);
                let bestCol = availableMoves[Math.floor(Math.random() * availableMoves.length)];

                if (isMaximizing) {
                    let bestScore = -Infinity;
                    for (const col of availableMoves) {
                        let tempBoard = board.map(row => [...row]);
                        this.dropPiece(tempBoard, col, this.aiPlayer);
                        let newScore = this.minimax(tempBoard, depth - 1, alpha, beta, false).score;
                        if (newScore > bestScore) {
                            bestScore = newScore;
                            bestCol = col;
                        }
                        alpha = Math.max(alpha, bestScore);
                        if (alpha >= beta) break;
                    }
                    return { col: bestCol, score: bestScore };
                } else { // Minimizing player
                    let bestScore = Infinity;
                    for (const col of availableMoves) {
                         let tempBoard = board.map(row => [...row]);
                         this.dropPiece(tempBoard, col, this.humanPlayer);
                         let newScore = this.minimax(tempBoard, depth - 1, alpha, beta, true).score;
                         if (newScore < bestScore) {
                             bestScore = newScore;
                             bestCol = col;
                         }
                         beta = Math.min(beta, bestScore);
                         if (alpha >= beta) break;
                    }
                    return { col: bestCol, score: bestScore };
                }
            },
            
            isTerminalNode(board) {
                if (this.checkWin(board, this.humanPlayer)) return { result: true, winner: this.humanPlayer};
                if (this.checkWin(board, this.aiPlayer)) return { result: true, winner: this.aiPlayer};
                if (board.flat().every(cell => cell !== 0)) return { result: true, winner: null}; // Draw
                return { result: false };
            },
            
            dropPiece(board, col, player) {
                for(let r = this.ROWS - 1; r >= 0; r--) {
                    if (board[r][col] === 0) {
                        board[r][col] = player;
                        return r;
                    }
                }
                return -1;
            },

            evaluateBoard(board, player) {
                let score = 0;
                // Score center column
                const centerCol = board.map(row => row[Math.floor(this.COLS / 2)]);
                score += centerCol.filter(p => p === player).length * 3;

                // Score Horizontal
                for (let r = 0; r < this.ROWS; r++) {
                    for (let c = 0; c <= this.COLS - 4; c++) {
                        const window = board[r].slice(c, c + 4);
                        score += this.evaluateWindow(window, player);
                    }
                }
                // Score Vertical
                for (let c = 0; c < this.COLS; c++) {
                    for (let r = 0; r <= this.ROWS - 4; r++) {
                        const window = [board[r][c], board[r+1][c], board[r+2][c], board[r+3][c]];
                        score += this.evaluateWindow(window, player);
                    }
                }
                // Score Diagonal /
                for (let r = 3; r < this.ROWS; r++) {
                    for (let c = 0; c <= this.COLS - 4; c++) {
                        const window = [board[r][c], board[r-1][c+1], board[r-2][c+2], board[r-3][c+3]];
                         score += this.evaluateWindow(window, player);
                    }
                }
                 // Score Diagonal \
                for (let r = 0; r <= this.ROWS - 4; r++) {
                    for (let c = 0; c <= this.COLS - 4; c++) {
                        const window = [board[r][c], board[r+1][c+1], board[r+2][c+2], board[r+3][c+3]];
                        score += this.evaluateWindow(window, player);
                    }
                }
                return score;
            },
            
            evaluateWindow(window, player) {
                let score = 0;
                const opponent = player === this.humanPlayer ? this.aiPlayer : this.humanPlayer;
                const playerCount = window.filter(p => p === player).length;
                const opponentCount = window.filter(p => p === opponent).length;
                const emptyCount = window.filter(p => p === 0).length;

                if (playerCount === 4) score += 100;
                else if (playerCount === 3 && emptyCount === 1) score += 5;
                else if (playerCount === 2 && emptyCount === 2) score += 2;
                
                if (opponentCount === 3 && emptyCount === 1) score -= 4;

                return score;
            }
        };

    const Hangman = {
        words: [
            'APPLE', 'BAKER', 'CANDY', 'DREAM', 'EAGLE', 'FROST', 'GRAPE', 'HOUSE', 'IGLOO', 'JUICE',
            'KITES', 'LEMON', 'MANGO', 'NIGHT', 'OCEAN', 'PLANT', 'QUEEN', 'RIVER', 'SPACE', 'TABLE',
            'UMBRELLA', 'VIOLIN', 'WATER', 'XYLOPHONE', 'YACHT', 'ZEBRA', 'ACTOR', 'BUILD', 'CLOUD', 'DAISY',
            'EARTH', 'FLAME', 'GLOWS', 'HAPPY', 'IDEAS', 'JUMPY', 'KNIFE', 'LAUGH', 'MAGIC', 'NOBLE',
            'OPERA', 'PEACE', 'QUIET', 'ROBIN', 'SHINE', 'TIGER', 'UNITY', 'VIOLET', 'WAVES', 'XENON',
            'YUMMY', 'ZODIAC', 'ALMOND', 'BRAVO', 'CRISP', 'DELISH', 'ELEGANT', 'FLIGHT', 'GIANT', 'HASTY',
            'INDEX', 'JAZZY', 'KOALA', 'LIGHT', 'MONTH', 'NORTH', 'OLIVE', 'PEACH', 'QUICK', 'ROUND',
            'SMART', 'TRUST', 'URBAN', 'VIVID', 'WIDOW', 'XENIAL', 'YIELD', 'ZILLION', 'ABOARD', 'BLEACH',
            'CAVITY', 'DECEIT', 'ENTIRE', 'FRENCH', 'GLOBAL', 'HEIGHT', 'INCOME', 'JESTER', 'KERNEL', 'LISTEN',
            'MERCY', 'NICKEL', 'OFFSET', 'PENCIL', 'QUORUM', 'RUSTIC', 'SEARCH', 'TANGLE', 'UNIQUE', 'VENTURE',
            'WINDOW', 'XENOPHOBIA', 'YELLOW', 'ZIGZAG'
        ],
        word: '', guessedLetters: [], wrongGuesses: 0,
        statusDisplay: null, wordDisplay: null, keysDisplay: null, parts: [],
        init() {
            this.statusDisplay = document.getElementById('hangman-status');
            this.wordDisplay = document.getElementById('hangman-word');
            this.keysDisplay = document.getElementById('hangman-keys');
            this.parts = document.querySelectorAll('#hangman-drawing .hangman-part:not([id^="hangman-scaffold"])');
            document.getElementById('hangman-restart-btn').addEventListener('click', () => this.init());
            this.startGame();
        },
        startGame() {
            this.word = this.words[Math.floor(Math.random() * this.words.length)];
            this.guessedLetters = []; this.wrongGuesses = 0;
            this.statusDisplay.textContent = 'Guess the word!';
            this.parts.forEach(part => part.style.display = 'none');
            this.drawWord(); this.drawKeys();
        },
        drawWord() {
            this.wordDisplay.innerHTML = this.word.split('').map(letter =>
                `<div class="letter-placeholder">${this.guessedLetters.includes(letter) ? letter : ''}</div>`
            ).join('');
        },
        drawKeys() {
            this.keysDisplay.innerHTML = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('').map(key =>
                `<button class="key-btn" data-key="${key}">${key}</button>`
            ).join('');
            this.keysDisplay.querySelectorAll('.key-btn').forEach(btn =>
                btn.addEventListener('click', e => this.handleGuess(e.target.dataset.key, e.target))
            );
        },
        handleGuess(key, btn) {
            btn.disabled = true; this.guessedLetters.push(key);
            if (this.word.includes(key)) {
                this.drawWord();
                const wordGuessed = this.word.split('').every(letter => this.guessedLetters.includes(letter));
                if (wordGuessed) {
                    this.statusDisplay.textContent = 'You Win!';
                    this.keysDisplay.querySelectorAll('.key-btn').forEach(b => b.disabled = true);
                }
            } else {
                this.wrongGuesses++;
                if(this.wrongGuesses <= this.parts.length) this.parts[this.wrongGuesses - 1].style.display = 'block';
                if (this.wrongGuesses === this.parts.length) {
                    this.statusDisplay.textContent = `You Lose! The word was: ${this.word}`;
                    this.keysDisplay.querySelectorAll('.key-btn').forEach(b => b.disabled = true);
                }
            }
        }
    };
    const Puzzle = {
        boardEl: null,
        statusDisplay: null,
        restartBtn: null,
        tiles: [],
        gameOver: false,

        init() {
            this.boardEl = document.getElementById('puzzle-board');
            this.statusDisplay = document.getElementById('puzzle-status');
            this.restartBtn = document.getElementById('puzzle-restart-btn');
            this.restartBtn.addEventListener('click', () => this.startGame());
            this.startGame();
        },

        startGame() {
            this.gameOver = false;
            this.statusDisplay.textContent = 'Solve the puzzle!';
            this.boardEl.classList.remove('win');
            this.tiles = [1, 2, 3, 4, 5, 6, 7, 8, 0]; // 0 represents the empty tile
            this.shuffle();
            this.drawBoard();
        },

        drawBoard() {
            this.boardEl.innerHTML = '';
            this.tiles.forEach((num, index) => {
                const tile = document.createElement('div');
                tile.className = 'puzzle-tile';
                if (num === 0) {
                    tile.classList.add('empty');
                } else {
                    tile.textContent = num;
                    tile.addEventListener('click', () => this.handleTileClick(index));
                }
                this.boardEl.appendChild(tile);
            });
            this.checkWin();
        },

        shuffle() {
            // Perform a large number of random valid moves to shuffle
            let emptyIndex = this.tiles.indexOf(0);
            for (let i = 0; i < 500; i++) {
                const neighbors = this.getNeighbors(emptyIndex);
                const randomNeighborIndex = neighbors[Math.floor(Math.random() * neighbors.length)];
                this.swapTiles(emptyIndex, randomNeighborIndex);
                emptyIndex = randomNeighborIndex;
            }
            // Ensure it's not solved after shuffling
            if (this.isSolved()) {
                this.shuffle();
            }
        },
        
        getNeighbors(index) {
            const neighbors = [];
            const row = Math.floor(index / 3);
            const col = index % 3;
            if (row > 0) neighbors.push(index - 3); // Up
            if (row < 2) neighbors.push(index + 3); // Down
            if (col > 0) neighbors.push(index - 1); // Left
            if (col < 2) neighbors.push(index + 1); // Right
            return neighbors;
        },

        handleTileClick(index) {
            if (this.gameOver) return;

            const emptyIndex = this.tiles.indexOf(0);
            const neighbors = this.getNeighbors(emptyIndex);
            
            if (neighbors.includes(index)) {
                this.swapTiles(index, emptyIndex);
                this.drawBoard();
            }
        },

        swapTiles(index1, index2) {
            [this.tiles[index1], this.tiles[index2]] = [this.tiles[index2], this.tiles[index1]];
        },

        isSolved() {
            for(let i = 0; i < this.tiles.length - 1; i++) {
                if (this.tiles[i] !== i + 1) return false;
            }
            return this.tiles[this.tiles.length - 1] === 0;
        },

        checkWin() {
            if (this.isSolved()) {
                this.gameOver = true;
                this.statusDisplay.textContent = 'You Win!';
                this.boardEl.classList.add('win');
            }
        }
    };

    // --- Original Main Control Logic ---
    const tabLinks = document.querySelectorAll('.tab-link');
    const gameWrappers = document.querySelectorAll('.game-wrapper');
    let activeGame = null;
    let gameInterval = null;

    const gameInits = {
        'tic-tac-toe': TicTacToe.init.bind(TicTacToe),
        'rps': RockPaperScissors.init.bind(RockPaperScissors),
        'memory': MemoryGame.init.bind(MemoryGame),
        'snake': Snake.init.bind(Snake),
        'connect4': Connect4.init.bind(Connect4),
        'hangman': Hangman.init.bind(Hangman),
        'puzzle': Puzzle.init.bind(Puzzle),
    };

    function switchGame(gameId) {
        if (gameId === activeGame && document.getElementById(gameId).classList.contains('active')) return;
        
        // Stop listeners/intervals from the old game
        if (activeGame) {
             if (gameInterval) { clearInterval(gameInterval); gameInterval = null; }
            if (activeGame === 'snake') Snake.stop();
            if (activeGame === 'tic-tac-toe') TicTacToe.stop();
        }
        
        activeGame = gameId;
        tabLinks.forEach(link => link.classList.toggle('active', link.dataset.game === gameId));
        gameWrappers.forEach(wrapper => {
            wrapper.classList.toggle('active', wrapper.id === gameId);
        });
        if (gameInits[gameId]) gameInits[gameId]();
    }
    
    // --- HOME UI VISIBILITY TOGGLING START ---
    const homeView = document.getElementById('home-view');
    const gameView = document.getElementById('game-view');
    const backButton = document.getElementById('back-button');
    const gameCards = document.querySelectorAll('.game-card');

    gameCards.forEach(card => {
        card.addEventListener('click', () => {
            const gameId = card.dataset.game;
            
            // Use the existing game switching logic
            switchGame(gameId);

            // Toggle views
            homeView.classList.add('hidden');
            gameView.classList.remove('hidden');
            backButton.classList.remove('hidden');
        });
    });

    backButton.addEventListener('click', () => {
        homeView.classList.remove('hidden');
        gameView.classList.add('hidden');
        backButton.classList.add('hidden');
    });

    // On initial load, don't auto-start a game
    gameWrappers.forEach(wrapper => wrapper.classList.remove('active'));
    // --- HOME UI VISIBILITY TOGGLING END ---
});
</script>

</body>
</html>